<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Zane,pi@0php.net"><title>HTML 表单之不得不知 enctype · 一只贱熊猫的博客</title><meta name="description" content="0x00 前言初学 Web 编程的时候发现想通过 HTML 表单上传文件的时候发现只需要简单的设置 form 标签的 enctype 属性为 multipart/form-data 便能成功的实现，后面才知道其实这是在设置表单内容的编码并且设置 HTTP 请求头的 Content-Type 属性。而"><meta name="keywords" content="PHP,Web,Swoole,HTML,CSS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">一只贱熊猫的博客</a></h3><div class="description"><p>夫夷以近，则游者众；险以远，则至者少。</p></div></div></div><ul class="social-links"><li><a href="http://github.com/zanemmm"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>HTML 表单之不得不知 enctype</a></h3></div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>初学 Web 编程的时候发现想通过 HTML 表单上传文件的时候发现只需要简单的设置 <code>form</code> 标签的 <code>enctype</code> 属性为 <code>multipart/form-data</code> 便能成功的实现，后面才知道其实这是在设置表单内容的编码并且设置 <code>HTTP</code> 请求头的 <code>Content-Type</code> 属性。而在 <a href="https://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noopener">W3C</a> 标准里要求浏览器必须支持 <code>application/x-www-form-urlencoded</code> 和 <code>multipart/form-data</code> 这两种 <code>enctype</code> 方式，下面就来解释一下这两种类型吧！</p>
<h2 id="0x01-application-x-www-form-urlencoded"><a href="#0x01-application-x-www-form-urlencoded" class="headerlink" title="0x01 application/x-www-form-urlencoded"></a>0x01 application/x-www-form-urlencoded</h2><p><strong>注意：application/x-www-form-urlencoded 类型无法用于具有文件上传功能的表单。</strong></p>
<p>浏览器 <code>form</code> 标签的 <code>enctype</code> 属性默认即为 <code>application/x-www-form-urlencoded</code>，从字面上看我们看到了一个 <code>urlencoded</code>。猜测是不是和 <code>URL</code> 相关？没错其实这种方式就是把我们平常用的 <code>GET</code> 方法所提交的参数放在了 <code>HTTP</code> 请求的 <code>body</code> 里，下面是一个通过 <code>URL</code> 传参例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8000/?keyword=panda&amp;author=zane</span><br></pre></td></tr></table></figure>
<p>可以看见重点在于 <code>?</code> 号后面的部分，这部分指定了传递的参数的键和值。然后我们看一下通过 Postman 指定 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 所发送的 <code>POST</code> 请求报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST  HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8000</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Postman-Token: e8c31d7a-fd52-cbf2-2741-07d73cb1101b</span><br><span class="line"></span><br><span class="line">keyword=panda&amp;author=zane</span><br></pre></td></tr></table></figure>
<p>通过比较，发现请求体中的内容和<code>URL</code> 中 <code>?</code> 后的内容相等。</p>
<p><strong>注意：和 URL 编码一致，当内容出现非 ASCII 字符时会被编码为 %HH 的形式（H是十六进制数的意思⊙o⊙）。</strong></p>
<p>现在我们来点更详细的，将前面 <code>URL</code> 对应的 <code>GET</code> 请求报文贴出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /?keyword=panda&amp;author=zane HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8000</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Postman-Token: 43550a7c-2579-cea1-5dd5-55cbfac077f8</span><br></pre></td></tr></table></figure>
<p>可以看见 <code>HTTP</code> 请求的 <code>body</code> 部分为空，所传递的参数在第一行（请求行）的 <code>URL</code> 里。所以当有人问你 <code>HTTP</code> 中 <code>GET</code> 和 <code>POST</code> 的区别的时候，你就可以告诉他「<code>GET</code> 将请求数据放在 <code>URL</code> 里， <code>POST</code> 将请求数据放在请求体里」。</p>
<h3 id="偏题内容：为何说-GET-方法能提交数据要比-POST-少？"><a href="#偏题内容：为何说-GET-方法能提交数据要比-POST-少？" class="headerlink" title="偏题内容：为何说  GET 方法能提交数据要比  POST 少？"></a>偏题内容：为何说  GET 方法能提交数据要比  POST 少？</h3><p>我在了解了 <code>TCP</code> 协议后便觉得其实 <code>GET</code> 和 <code>POST</code> 并无区别，因为对于 <code>TCP</code> 协议来说都只是数据而已。站在传输层的角度来说 <code>URL</code> 应该可以无限长，所以使用 <code>GET</code> 能提交数据不应该比 <code>POST</code> 少。但事实真的如此吗？稍微作个实验就知道是错的，因为这个限制出自「浏览器」和「 Web 服务器」。从浏览器的角度考虑，允许输入一个无限长文本的地址栏很明显就是一个错误的设计。此外在服务器的角度来说，因为 <code>URL</code> 在 <code>HTTP</code> 报文的第一行，如果允许 <code>URL</code> 无限长就意味着要等待 <code>URL</code> 全部接收完毕才可以获取其它头信息和请求体，对于一些需要验证某些头字段后才允许访问页面来说无疑带来了极大的资源的浪费（比如说接收到了一个很长的 <code>URL</code>，但是后面的请求头的字段内容错误或者干脆就是不符合 <code>HTTP</code> 格式，这样前面接收 <code>URL</code> 所耗费的资源不都统统浪费了吗？ ），这样不限制 <code>URL</code> 长度便容易被人所以利用攻击。因此大多数的「浏览器」和「 Web 服务器」都有限制 <code>URL</code> 长度，所以说在提交表单 <code>POST</code> 还是比 <code>GET</code> 好滴O(∩_∩)O！如果想了解更多的内容可以在 StackOverflow 上看这个问题 <a href="https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers" target="_blank" rel="noopener">What is the maximum length of a URL in different browsers?</a>，本人技术浅薄不敢多言(ㄒoㄒ)。</p>
<h2 id="0x02-multipart-form-data"><a href="#0x02-multipart-form-data" class="headerlink" title="0x02 multipart/form-data"></a>0x02 multipart/form-data</h2><p><code>multipart/form-data</code> 比 <code>application/x-www-form-urlencoded</code> 要复杂，和上面提交同样的数据，报文如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8000</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Postman-Token: 090df52c-d103-279b-1479-50e6a7fef58b</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;keyword&quot;</span><br><span class="line"></span><br><span class="line">panda</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;author&quot;</span><br><span class="line"></span><br><span class="line">zane</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure>
<p>首先我们看请求头的 <code>Content-Type</code> 它除了正常的 <code>multipart/form-data</code> 外还多了一个 <code>boundary</code> ，这个 <code>boundary</code> 的意思和字面意思一样就是分界线，通过分界线将每个键值对用 <code>boundary</code> 分割开来以示区别。现在我们看请求体，我们注意到<code>boundary</code> 将键值对分割后的每一部分都有 <code>Content-Disposition</code> 字段，实际上该字段的值必须为 <code>form-data</code> 而且后面必须加上 <code>name</code> 指定这部分的键名，然后是一行空行，空行之后便是提交数据的内容。 之所以要弄的这么复杂是因为 <code>multipart/form-data</code> 要支持文件上传。下面是一个包含文件上传的示例报文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: 127.0.0.1:8000</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Postman-Token: 8c62dfea-a64e-aeda-5f5a-d40557edfb18</span><br><span class="line">Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;keyword&quot;</span><br><span class="line"></span><br><span class="line">panda</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;author&quot;</span><br><span class="line"></span><br><span class="line">zane</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;logo.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">// 文件内容</span><br><span class="line">------WebKitFormBoundary7MA4YWxkTrZu0gW--</span><br></pre></td></tr></table></figure>
<p>得益于分界线使每部分内容都可以分开，所以文件的内容可以直接以二进制传输而不用经过编码。另外上传文件应该通过 <code>filename</code> 指定文件名并且通过 <code>Content-Type</code> 指定文件的 MIME 类型。</p>
<h3 id="PHP-关于-multipart-form-data-的坑"><a href="#PHP-关于-multipart-form-data-的坑" class="headerlink" title="PHP 关于 multipart/form-data 的坑"></a>PHP 关于 multipart/form-data 的坑</h3><p>注意 PHP 默认只解析 <code>POST</code> 方法的 <code>multipart/form-data</code> 请求（就是只有发送 <code>POST</code> 请求时才能获取到 <code>multipart/form-data</code> 提交的内容），也就说如果用其它的方法如 <code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code> 发送 <code>multipart/form-data</code> 类型的请求，PHP 默认不会解析所以获取不到内容（当然大神可以自己通过 <code>php://input</code> 解析内容），但 <code>application/x-www-form-urlencoded</code> 是都可以用的。遇到这个坑是因为在使用 Postman 调试 API 时发现请求的参数怎么都获取不到，结果发现 Postman 选了 <code>multipart/form-data</code> 类型，然后请求方法是 <code>PUT</code>。原来代码一切正常，却调了半天(ㄒoㄒ)……</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>最后附上两条终极链接 <a href="https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data" target="_blank" rel="noopener">application/x-www-form-urlencoded or multipart/form-data?</a> <a href="https://www.w3.org/TR/html401/interact/forms.html" target="_blank" rel="noopener">HTML 表单之必知必会（手动狗头）</a>，O(∩_∩)O哈哈~~如果能看完就肯定会觉得我写的很垃圾了(ㄒoㄒ)。文章有误欢迎指出，欢迎友好讨论！</p>
</div><br><p>转载请注明出处:<a href="https://www.0php.net/posts/HTML-表单之不得不知-enctype.html" target="_blank" title="https://www.0php.net/posts/HTML-表单之不得不知-enctype.html">https://www.0php.net/posts/HTML-表单之不得不知-enctype.html</a></p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><p>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。</p><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-09-02</span><i class="fa fa-comment-o"></i><a href="/posts/HTML-表单之不得不知-enctype.html#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/tags/HTML/" title="HTML">HTML </a><a class="tag" href="/tags/HTTP/" title="HTTP">HTTP </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://www.0php.net/posts/HTML-表单之不得不知-enctype.html,一只贱熊猫的博客,HTML 表单之不得不知 enctype,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/posts/PHP-面向-StackOverflow-编程.html" title="PHP 面向 StackOverflow 编程">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'zanemmm';
var disqus_identifier = 'posts/HTML-表单之不得不知-enctype.html';
var disqus_title = 'HTML 表单之不得不知 enctype';
var disqus_url = 'https://www.0php.net/posts/HTML-表单之不得不知-enctype.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>