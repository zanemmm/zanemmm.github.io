<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Zane,pi@0php.net"><title>PHP Clourse(闭包类) 浅析 · 一只贱熊猫的博客</title><meta name="description" content="0x00 前言
闭包是指在创建时封装周围状态的函数。即使闭包所在的环境不存在了，闭包中封装的状态依然存在。

在 PHP 里所有的闭包都是 Clourse 类所实例化的一个对象，也就是说闭包与其他 PHP 对象没有什么不同。而一个对象就必然有其方法和属性，这篇文章将总结 PHP 中闭包的基础用法和 "><meta name="keywords" content="PHP,Web,Swoole,HTML,CSS"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">一只贱熊猫的博客</a></h3><div class="description"><p>夫夷以近，则游者众；险以远，则至者少。</p></div></div></div><ul class="social-links"><li><a href="http://github.com/zanemmm"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>PHP Clourse(闭包类) 浅析</a></h3></div><div class="post-content"><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><blockquote>
<p>闭包是指在创建时封装周围状态的函数。即使闭包所在的环境不存在了，闭包中封装的状态依然存在。</p>
</blockquote>
<p>在 PHP 里所有的闭包都是 <code>Clourse</code> 类所实例化的一个对象，也就是说闭包与其他 PHP 对象没有什么不同。而一个对象就必然有其方法和属性，这篇文章将总结 PHP 中闭包的基础用法和 <code>Clourse</code> 类方法的作用。</p>
<h2 id="0x01-闭包基本用法"><a href="#0x01-闭包基本用法" class="headerlink" title="0x01 闭包基本用法"></a>0x01 闭包基本用法</h2><p>下面看看最基本的闭包使用方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$hello = <span class="function"><span class="keyword">function</span> <span class="params">($word)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello '</span> . $word;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $hello(<span class="string">'world'</span>);</span><br><span class="line"><span class="comment">// 输出 hello world</span></span><br></pre></td></tr></table></figure>
<p>嘿，这段代码最直观的感受就是将一个函数赋值给了 <code>$hello</code> 变量，然后通过 <code>$hello</code> 直接调用它。但是这个闭包并没有从父作用域中继承变量（就是封装周围状态），我们可以通过 <code>use</code> 关键字从闭包的父作用域继承变量。示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name = <span class="string">'panda'</span>;</span><br><span class="line"></span><br><span class="line">$hello = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello '</span> . $name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $hello();</span><br><span class="line"><span class="comment">// 输出 hello panda</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>PHP 7.1 起，<code>use</code> 不能传入此类变量： <a href="http://php.net/manual/zh/language.variables.predefined.php" target="_blank" rel="noopener">superglobals</a>、 $this 或者和参数重名。</strong></p>
</blockquote>
<p>此外在使用 <code>use</code> 关键字时，父作用域的变量是通过值传递进闭包的。也就是说一旦闭包创建完成，外部的变量即使修改也不会影响传递进闭包内的值（就是即使闭包所在的环境不存在了，闭包中封装的状态依然存在）。示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name = <span class="string">'panda'</span>;</span><br><span class="line"></span><br><span class="line">$hello = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello '</span> . $name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$name = <span class="string">'cat'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $hello();</span><br><span class="line"><span class="comment">// 输出 hello panda</span></span><br></pre></td></tr></table></figure>
<p>传递变量的引用可以使闭包修改外部变量的值，示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$name = <span class="string">'panda'</span>;</span><br><span class="line"></span><br><span class="line">$changeName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">(&amp;$name)</span> </span>&#123;</span><br><span class="line">    $name = <span class="string">'cat'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$changeName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $name;</span><br><span class="line"><span class="comment">// 输出 cat</span></span><br></pre></td></tr></table></figure>
<p>注意：PHP 中传递对象时，默认是以引用传递所以在闭包内操作 <code>use</code> 传递的对象时需要特别注意。示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">'Wang Cai'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$dog = <span class="keyword">new</span> Dog();</span><br><span class="line"></span><br><span class="line">$changeName = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="title">use</span> <span class="params">($dog)</span> </span>&#123;</span><br><span class="line">    $dog-&gt;name = <span class="string">'Lai Fu'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$changeName();</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> $dog-&gt;name;</span><br><span class="line"><span class="comment">// 输出 Lai Fu</span></span><br></pre></td></tr></table></figure>
<h2 id="0x02-Clourse-类"><a href="#0x02-Clourse-类" class="headerlink" title="0x02 Clourse 类"></a>0x02 Clourse 类</h2><h3 id="证明闭包只是-Clourse-类对象"><a href="#证明闭包只是-Clourse-类对象" class="headerlink" title="证明闭包只是 Clourse 类对象"></a>证明闭包只是 Clourse 类对象</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$clourse = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">'hello clourse'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_object($clourse)) &#123;</span><br><span class="line">    <span class="keyword">echo</span> get_class($clourse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 Closure</span></span><br></pre></td></tr></table></figure>
<p>上面的代码将输出 Closure 证明了闭包只是一个普通的 <code>Closure</code> 类对象。</p>
<h3 id="Clourse-类摘要"><a href="#Clourse-类摘要" class="headerlink" title="Clourse 类摘要"></a>Clourse 类摘要</h3><p>我们可以从 <a href="http://www.php.net/manual/en/class.closure.php" target="_blank" rel="noopener">PHP 官方手册</a> 看到闭包类的相关信息，下面是我在 PhpStorm 的本地文档查看到 <code>Clourse</code> 类摘要。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class used to represent anonymous functions.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Anonymous functions, implemented in PHP 5.3, yield objects of this type.</span></span><br><span class="line"><span class="comment"> * This fact used to be considered an implementation detail, but it can now be relied upon.</span></span><br><span class="line"><span class="comment"> * Starting with PHP 5.4, this class has methods that allow further control of the anonymous function after it has been created.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Besides the methods listed here, this class also has an __invoke method.</span></span><br><span class="line"><span class="comment"> * This is for consistency with other classes that implement calling magic, as this method is not used for calling the function.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@link</span> http://www.php.net/manual/en/class.closure.php</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Closure</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method exists only to disallow instantiation of the Closure class.</span></span><br><span class="line"><span class="comment">     * Objects of this class are created in the fashion described on the anonymous functions page.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@link</span> http://www.php.net/manual/en/closure.construct.php</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This is for consistency with other classes that implement calling magic,</span></span><br><span class="line"><span class="comment">     * as this method is not used for calling the function.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mixed $_ [optional]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@link</span> http://www.php.net/manual/en/class.closure.php</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__invoke</span><span class="params">(...$_)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Duplicates the closure with a new bound object and class scope</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@link</span> http://www.php.net/manual/en/closure.bindto.php</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object $newthis The object to which the given anonymous function should be bound, or NULL for the closure to be unbound.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mixed $newscope The class scope to which associate the closure is to be associated, or 'static' to keep the current one.</span></span><br><span class="line"><span class="comment">     * If an object is given, the type of the object will be used instead.</span></span><br><span class="line"><span class="comment">     * This determines the visibility of protected and private methods of the bound object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Closure Returns the newly created Closure object or FALSE on failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bindTo</span><span class="params">($newthis, $newscope = <span class="string">'static'</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is a static version of Closure::bindTo().</span></span><br><span class="line"><span class="comment">     * See the documentation of that method for more information.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@static</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@link</span> http://www.php.net/manual/en/closure.bind.php</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Closure $closure The anonymous functions to bind.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object $newthis The object to which the given anonymous function should be bound, or NULL for the closure to be unbound.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mixed $newscope The class scope to which associate the closure is to be associated, or 'static' to keep the current one.</span></span><br><span class="line"><span class="comment">     * If an object is given, the type of the object will be used instead.</span></span><br><span class="line"><span class="comment">     * This determines the visibility of protected and private methods of the bound object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Closure Returns the newly created Closure object or FALSE on failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">(Closure $closure, $newthis, $newscope = <span class="string">'static'</span>)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Temporarily binds the closure to newthis, and calls it with any given parameters.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@link</span> http://php.net/manual/en/closure.call.php</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object $newThis The object to bind the closure to for the duration of the call.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mixed $parameters [optional] Zero or more parameters, which will be given as parameters to the closure.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 7.0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">call</span> <span class="params">($newThis, ...$parameters)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable $callable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Closure</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 7.1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">fromCallable</span> <span class="params">(callable $callable)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先 <code>Clourse</code> 类为 <code>final</code> 类，也就是说它将无法被继承，其次它的构造函数 <code>__construct</code> 被设为 <code>private</code> 即无法通过 <code>new</code> 关键字实例化闭包对象，这两点保证了闭包只能通过 <code>function (...) use(...) {...}</code> 这种语法实例化 。</p>
<h3 id="为什么闭包可以当作函数执行？"><a href="#为什么闭包可以当作函数执行？" class="headerlink" title="为什么闭包可以当作函数执行？"></a>为什么闭包可以当作函数执行？</h3><p>从上面的类摘要中我们看出 <code>Clourse</code> 类实现了 <a href="http://php.net/manual/zh/language.oop5.magic.php#object.invoke" target="_blank" rel="noopener">__invoke</a> 方法，在 PHP 官方手册中对该方法解释如下：</p>
<blockquote>
<p>当尝试以调用函数的方式调用一个对象时，<a href="http://php.net/manual/zh/language.oop5.magic.php#object.invoke" target="_blank" rel="noopener">__invoke()</a> 方法会被自动调用。</p>
</blockquote>
<p>这就是闭包可以被当作函数执行的原因。</p>
<h3 id="绑定指定的-this对象和类作用域"><a href="#绑定指定的-this对象和类作用域" class="headerlink" title="绑定指定的$this对象和类作用域"></a>绑定指定的$this对象和类作用域</h3><p>在允许使用闭包路由的框架中（如：Slim），我们可以看见如下写法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;get(<span class="string">'/test'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;request-&gt;getMethod();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在一个闭包居然能中使用 <code>$this</code>？这个 <code>$this</code> 指向哪个对象？</p>
<p>通过 <code>bindTo</code> 和 <code>bind</code> 方法都能够实现绑定 <code>$this</code> 和类作用域的功能，示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pandas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$pandas = <span class="keyword">new</span> Pandas();</span><br><span class="line"></span><br><span class="line">$add = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> ++<span class="keyword">$this</span>-&gt;num . PHP_EOL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$newAdd1 = $add-&gt;bindTo($pandas);</span><br><span class="line">$newAdd1();</span><br><span class="line"><span class="comment">// 输出 2</span></span><br><span class="line">$newAdd2 = Closure::bind($add, $pandas);</span><br><span class="line">$newAdd2();</span><br><span class="line"><span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<p>上面的这段例子将指定对象绑定为闭包的 <code>$this</code>，但是我们并没有指定类作用域。所以如果将 <code>Pandas</code> 类的 <code>$num</code> 属性改写为 <code>protected</code> 或 <code>private</code> 则会抛出一个致命错误！</p>
<blockquote>
<p>Fatal error: Uncaught Error: Cannot access protected property Pandas::$num</p>
</blockquote>
<p>在需要访问绑定对象的非公开属性或方法时，我们需要指定类作用域，示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pandas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$pandas = <span class="keyword">new</span> Pandas();</span><br><span class="line"></span><br><span class="line">$add = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> ++<span class="keyword">$this</span>-&gt;num . PHP_EOL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$newAdd1 = $add-&gt;bindTo($pandas, $pandas);</span><br><span class="line">$newAdd1();</span><br><span class="line"><span class="comment">// 输出 2</span></span><br><span class="line">$newAdd2 = Closure::bind($add, $pandas, <span class="string">'Pandas'</span>);</span><br><span class="line">$newAdd2();</span><br><span class="line"><span class="comment">// 输出 3</span></span><br></pre></td></tr></table></figure>
<p>这里我们看见 <code>bindTo</code> 和 <code>bind</code> 方法都指定了 <code>$newscope</code> 参数，<code>$newscope</code> 参数默认为 <code>static</code> 即不改变类作用域。<code>$newscope</code> 参数接受类名或对象，并将闭包的类作用域改为指定的类作用域，此时 <code>Pandas</code> 类的 <code>$num</code> 属性便能够被闭包访问。</p>
<h3 id="一次性绑定-this-对象和类作用域并执行（PHP7）"><a href="#一次性绑定-this-对象和类作用域并执行（PHP7）" class="headerlink" title="一次性绑定 $this 对象和类作用域并执行（PHP7）"></a>一次性绑定 $this 对象和类作用域并执行（PHP7）</h3><p><code>bindTo</code> 和 <code>bind</code> 方法每次指定新的对象和类作用域时都要将原闭包进行复制然后返回新的闭包，在需要多次修改绑定对象的情景下便显得繁琐，所以 PHP7 提供了一个新的方法 <code>call</code> 它能将闭包临时的绑定到一个对象中（类作用域同时被修改为该对象所属的类）并执行。示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pandas</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $num = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$pandas = <span class="keyword">new</span> Pandas();</span><br><span class="line"></span><br><span class="line">$add = <span class="function"><span class="keyword">function</span> <span class="params">($num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;num += $num;</span><br><span class="line">    <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;num . PHP_EOL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">$add-&gt;call($pandas, <span class="number">5</span>);</span><br><span class="line"><span class="comment">// 输出 6</span></span><br></pre></td></tr></table></figure>
<h3 id="Callable-转为闭包（PHP7-1）"><a href="#Callable-转为闭包（PHP7-1）" class="headerlink" title="Callable 转为闭包（PHP7.1）"></a>Callable 转为闭包（PHP7.1）</h3><p>在 PHP7.1 中 <code>Closure</code> 类存在 <code>fromCallable</code> 方法能够将 <code>callable</code> 类型的值转为闭包，示例如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">hello</span><span class="params">(string $bar)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'hello '</span> . $bar;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$hello = Closure::fromCallable([<span class="string">'Foo'</span>, <span class="string">'hello'</span>]);</span><br><span class="line">$hello(<span class="string">'world'</span>);</span><br></pre></td></tr></table></figure>
<p>这种写法还是挺爽的毕竟通过闭包调用总比用 <code>call_user_func</code> 函数调用爽的多^_^。</p>
<h2 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h2><p>更多相关内容请看 <a href="http://php.net/manual/en/class.closure.php" target="_blank" rel="noopener">Closure 类</a> 和 <a href="http://php.net/manual/zh/functions.anonymous.php" target="_blank" rel="noopener">匿名函数</a>，因为 PHP 官方手册中文版的 Closure 类没有更新，所以没有 <code>call</code> 和 <code>fromCallable</code> 方法的内容，推荐大家看英文版(ㄒoㄒ)。 </p>
</div><br><p>转载请注明出处:<a href="https://www.0php.net/posts/PHP-Clourse-闭包类-浅析.html" target="_blank" title="https://www.0php.net/posts/PHP-Clourse-闭包类-浅析.html">https://www.0php.net/posts/PHP-Clourse-闭包类-浅析.html</a></p><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a><br /><p>本作品采用<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a>进行许可。</p><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-08-24</span><i class="fa fa-comment-o"></i><a href="/posts/PHP-Clourse-闭包类-浅析.html#comments">评论</a><i class="fa fa-tag"></i><a class="tag" href="/tags/PHP/" title="PHP">PHP </a><a class="tag" href="/tags/闭包/" title="闭包">闭包 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,https://www.0php.net/posts/PHP-Clourse-闭包类-浅析.html,一只贱熊猫的博客,PHP Clourse(闭包类) 浅析,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/posts/感悟.html" title="感悟">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'zanemmm';
var disqus_identifier = 'posts/PHP-Clourse-闭包类-浅析.html';
var disqus_title = 'PHP Clourse(闭包类) 浅析';
var disqus_url = 'https://www.0php.net/posts/PHP-Clourse-闭包类-浅析.html';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>